// T.C. = O(V + E)    S.C. = O(V)

class Solution
{
    //stack to store topo sort
    Stack<Integer> s = new Stack<>();
    
    //Function to return list of vertices in Topological order using DFS. 
    int[] topoSort(int V, ArrayList<ArrayList<Integer>> adj) 
    {
        //to store visited or unvisited status of each node
        HashMap<Integer, Boolean> visitedMap = new HashMap<Integer, Boolean>();
        for(int i=0; i<V; i++)
            visitedMap.put(i, false);
            
        for(int i=0; i<V; i++){
            if(visitedMap.get(i) == false)
                dfsTopoSort(i, visitedMap, adj);
        }
        
        int arr[] = new int[V];
        for(int i=0; i<V; i++)
            arr[i] = s.pop(); //lifo
        return arr;
    }
    
    void dfsTopoSort(int node, HashMap<Integer, Boolean> visitedMap, ArrayList<ArrayList<Integer>> adj){
        visitedMap.put(node, true);
        
        for(int neighbour : adj.get(node)){
            if(visitedMap.get(neighbour) == false)
                dfsTopoSort(neighbour, visitedMap, adj);
        }
        //we must push the node after its dfs call
        s.push(node);
    }
}
